@page
@model WebApplication2.Pages.ChooseStrategiesModel
@{
    ViewData["Title"] = "Step 2";
}

<head>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/osmtogeojson/osmtogeojson.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw/dist/leaflet.draw.css" />
    <script src="https://unpkg.com/leaflet-draw/dist/leaflet.draw.js"></script>
    <style>
        #map {
            height: 300px;
            width: 30%;
        }
    </style>
</head>

<h1>Step 2: Choose Strategies</h1>

<!-- File Upload Form -->
<form enctype="multipart/form-data" id="osmUploadForm">
    <input type="file" id="osmFileInput" accept=".osm" />
</form>

<div>
    <div>UAV data: @Model.UAVs.Count</div>
    <div>Area: @Model.GeoJsonData.Length km²</div>
</div>

<label for="radiusInput">Radius:</label>
<input type="number" id="radiusInput" value="100" min="0" step="10" />
<button id="updateRadiusButton">Update Radius</button>

<div id="map"></div>

<p>Here are some suggested strategies:</p>

@foreach (var strategy in Model.Strategies)
{
    <div>
        <h3>Option @(strategy.Id): @(strategy.Name)</h3>
        <p><strong>Technology:</strong> @(strategy.Description)</p>
        <div>
            <div>UAVs: @(strategy.UAVCount)</div>
            <div>Max Duration: @(strategy.MaxDuration)</div>
            <div>Max Range: @(strategy.MaxRange)</div>
            <div>Transmission Speed: @(strategy.TransmissionSpeed)</div>
        </div>
        <button onclick="chooseOption(@(strategy.Id))" class="btn btn-primary">Choose</button>
    </div>
}

<script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
<script>
    // Map Initialization
    const map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

    let buildingLayer, centerMarker, radiusCircle, croppedBuildings = [];
    let buildingFeatures = [];
    let centerCoordinates = [];

    // Clear the Map Layer
    function clearMap() {
        if (buildingLayer) map.removeLayer(buildingLayer);
        if (centerMarker) map.removeLayer(centerMarker);
        if (radiusCircle) map.removeLayer(radiusCircle);
    }

    // Handle OSM File Upload
    document.getElementById('osmFileInput').addEventListener('change', handleOSMFileUpload);

    function handleOSMFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return alert('Please select a valid OSM file.');

        const reader = new FileReader();
        reader.onload = function (e) {
            const osmData = e.target.result;
            try {
                const geoJsonData = osmtogeojson(new DOMParser().parseFromString(osmData, 'text/xml'));
                if (!geoJsonData || !geoJsonData.features) throw new Error('Invalid GeoJSON data.');

                clearMap();

                // Filter Buildings from GeoJSON
                buildingFeatures = geoJsonData.features.filter(feature =>
                    feature.properties?.building &&
                    ['Polygon', 'MultiPolygon'].includes(feature.geometry.type)
                );

                // Add Buildings Layer
                buildingLayer = L.geoJSON(buildingFeatures, {
                    style: { color: 'gray', weight: 2 }
                }).addTo(map);

                map.fitBounds(buildingLayer.getBounds());

                // Add Centroid Marker
                const centroid = turf.centroid(geoJsonData);
                centerCoordinates = centroid.geometry.coordinates;
                centerMarker = L.circleMarker([centerCoordinates[1], centerCoordinates[0]], {
                    color: 'red',
                    radius: 5
                }).addTo(map);

                updateRadiusCircle(parseFloat(document.getElementById('radiusInput').value));
            } catch (error) {
                alert('Invalid OSM file format or no buildings found.');
            }
        };

        reader.readAsText(file);
    }

    // Update Radius Circle
    function updateRadiusCircle(radiusInMeters) {
        if (isNaN(radiusInMeters) || radiusInMeters <= 0) return alert('Please enter a valid radius value.');

        if (radiusCircle) map.removeLayer(radiusCircle);

        radiusCircle = L.circle([centerCoordinates[1], centerCoordinates[0]], {
            color: 'pink',
            fillColor: 'pink',
            fillOpacity: 0.3,
            radius: radiusInMeters
        }).addTo(map);

        // Crop Buildings within the Radius
        croppedBuildings = buildingFeatures
            .map(feature => turf.intersect(feature, turf.circle(centerCoordinates, radiusInMeters / 1000, { units: 'kilometers' })))
            .filter(croppedFeature => croppedFeature !== null);

        if (buildingLayer) map.removeLayer(buildingLayer);

        buildingLayer = L.geoJSON(croppedBuildings, {
            style: { color: '#0078FF', weight: 2 }
        }).addTo(map);
    }

    // Update Radius on Button Click
    document.getElementById('updateRadiusButton').addEventListener('click', function () {
        const newRadius = parseFloat(document.getElementById('radiusInput').value);
        updateRadiusCircle(newRadius);
    });

    // Update Radius on Enter Key
    document.getElementById('radiusInput').addEventListener('keydown', function (event) {
        if (event.key === 'Enter') {
            const newRadius = parseFloat(document.getElementById('radiusInput').value);
            updateRadiusCircle(newRadius);
        }
    });

    // Navigate to Strategy Details
    function chooseOption(option) {
        window.location.href = '/StrategyDetails/' + option;
    }
</script>
